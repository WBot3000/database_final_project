MF Structure consists of:
	Attributes that uniquely identify each aggregation (A)
		Would be a list of names of fields (comes from V I think)
	The fields of the aggregates themselves (B)
		Would be a list of names of aggregates
	The actual values (C)
		Will be a dictonary
		Key: A tuple containing unique groupings of the attributes from (A)
		Value: A list containing each of the results (Index i of this list will correspond to index i of (B))

At the beginning:


First Scan:
For every record within the data...
	Make a tuple containing all the values specified by (A)
	Attempt to fetch a list from (C) using this tuple
	If the return value is undefined, then add [0, ..., 0] to (C) with the tuple as the key. Else do nothing.

Other Scans: The number of additional scans is equal to the number of values in (B)
For every record within the data...
	Make a tuple containing all the values specified by (A), and attempt to fetch a list from (C) using this tuple
	Check if record satisfies all conditions of the grouping variable (inside Ïƒ), if not, do nothing
	If it does, then perform the appropriate function on the ith column of the fetched list (i = scan number - 2)

Pseudocode:
grouping_variable = first part of the ith element of (B)
aggregate = second part of the ith element of (B)
field_name = third part of the ith element of (B)
get all of the conditions on that grouping variable (put them in a list I guess)
for all the records in the table:
	if (satisfies all conditions) { #This record is contained within the grouping variable
		fetch the list from (C) that corresponds to the tupple of that group
		switch statement that does something different depending on the aggregate value
	}


Output:
For every record within the data...
	Compare the result to G



NOTES:
All code should begin with the necessary imports, the template MF Structure, and a call to the database to fetch all the data. This is constant regardless of the specific query
The first place where variability occurs is in the intialization of the MF Structure, whose fields depend on the input

TODO:
First need to open file to write program to
Write a function that writes code for initializing the MF-Structure using the input and the template structure described above
Write a function that writes code for performing a scan on the table based on grouping variable conditions
Finally need to close file











NOTE: We can alter the input to be more convenient